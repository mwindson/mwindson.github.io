{"meta":{"title":"Hexo","subtitle":null,"description":null,"author":"John Doe","url":"http://yoursite.com"},"pages":[],"posts":[{"title":"rxjs笔记之Subject","slug":"rxjs笔记之Subject","date":"2018-06-08T08:37:31.926Z","updated":"2018-06-12T11:48:06.174Z","comments":true,"path":"2018/06/08/rxjs笔记之Subject/","link":"","permalink":"http://yoursite.com/2018/06/08/rxjs笔记之Subject/","excerpt":"","text":"Subjecthot 流和 cold 流rxjs中创建的数据流分为 hot 流和 cold 流。当 Observer 订阅数据流时，cold 流会从数据流的起始时间点吐出数据，而 hot 流会从订阅的时间点开始吐出数据。 cold 流实现的是单播，hot 流实现的是多播。 cold 流由interval、range、of等操作符创建。 hot 流的创建操作符包括fromPromise、fromEvent、fromEventPattern。这些操作符数据来源于外部，如 Promise 或 Dom 事件。 cold 流的数据在没有订阅者的情况下，数据都不会产生。可以认为，每个订阅者订阅的 cold 流是独立的数据流。 hot 流的数据产生与订阅者无关，在没有订阅者的情况下，数据仍然会产生，不过不会传入管道。可以认为，每个订阅者订阅的 hot 流是同一数据流。 subject 扮演的角色subject是一个 Observable,也是一个 Observer。 subject通过subject.next方法向 subject 中传入数据。因此subject可以接受另一个Observable的数据。 subject能通过调用subject.complete来停止数据传递，进入结束状态。 subjecet可以保存多个订阅自己的 Observer 列表，而Observable没有状态，不能记忆多个订阅者。 因此，subject可以通过接受一个 cold 流，并把流中的数据传递给多个订阅 subject 的订阅者，从而将一个 cold 流转化为一个 hot 流以实现多播。 let s1$ = Rx.Observable.interval(1000).take(4)let subject = new Rx.Subject()s1$.subscribe( value =&gt; &#123; subject.next(value) &#125;, error =&gt; &#123; subject.error(error) &#125;, () =&gt; &#123; subject.complete() &#125;)// 简写s1$.subscribe(subject) 多播操作符multicastmulticast是一个实例操作符，它可以通过接受一个 Subject 对象，将上游 cold 流转化为 hot 流。 const hotSource$ = coldSource$.multicast(new Subject()) connect 当Observer去订阅上述代码返回的 hot 数据流时，hotSource$并不会吐出数据给订阅者。 如果multicast操作符返回的是一个常规 hot 流，那么当无Observer订阅时，hot 流依然会吐出数据。为了防止数据丢失，Rxjs 使返回的 hot 流必须在调用hotSource$.connect()后，才会吐出数据并向订阅者传递。因此connect能够如闸门一样控制数据是否流出。 refCount refCount能够实现一种功能：当有Observer订阅数 &gt; 1 时，multicast返回的 hot 流开始传递数据，而订阅数减少为 0 时，自动退订上游流。 注意，如果要使用refCount，那么multicast需要接受返回一个Subject对象的函数作为参数。这是为了防止传入一个固定Subject对象后，一旦该Subject对象结束并不再接受数据，那么之后的Observer将不能获得数据。 const cold$ = Observable.interval(1000).take(3)// fixed Subejctlet hot$ = cold$.multicast(new Subject()).refCount()// Subject functionhot$ = cold$.multicast(() =&gt; new Subject()).refCount()hot$.subscribe(value =&gt; console.log('Observer 1: ' + value))setTimeout(() =&gt; &#123; hot$.subscribe(value =&gt; console.log('Observer 2: ' + value))&#125;, 1500)setTimeout(() =&gt; &#123; hot$.subscribe(value =&gt; console.log('Observer 2: ' + value))&#125;, 5000) selector 参数 selector接受一个shared参数，代表multicast接受的Subject对象。selector函数可以对shared进行一些流的操作，并返回一个新的数据流。selecotr可以多次使用上游数据，但不会重复订阅上游的数据。 当数据流出现三角依赖时，这时会发生重复订阅的问题 // delayedTick$ 依赖 tick$，而mergedTick$同时依赖delayedTick$和tick$// 本质上，mergedTick$只取决于tick$，应该订阅tick$一次而不是两次const cold$ = interval(1000).pipe( take(3), tap(x =&gt; console.log('source ', x)))const tick$ = cold$const delayedTick$ = tick$.pipe(delay(500))const mergedTick$ = merge(delayedTick$, tick$)// 发生了两次订阅mergedTick$.subscribe(value =&gt; console.log('observer :', value))// source 0// source 0// observer :0// observer :0// source 1// source 1// observer :1// observer :1 这时如果使用selector参数，就可以避免重复订阅的问题. const cold$ = interval(1000).pipe( take(2), tap(x =&gt; console.log('source ', x)))const result$ = cold$.pipe( multicast(new Subject(), shared =&gt; &#123; const tick$ = shared const delayedTick$ = tick$.pipe(delay(500)) return merge(delayedTick$, tick$) &#125;))result$.subscribe(value =&gt; console.log('observer :', value)) 这时候就上游源只会吐出一次 source 0observer :0observer :0source 1observer :1observer :1 publishpublish有一个可选selector参数。如果没有传入selector，那么等价于 multicast(new Subject()) 反之,则等价于 multicast(() =&gt; new Subject(), selector) shareshare等价于调用参数为 Subject 工厂函数的multicast，再调用refCount。 cold$.share()// 等价于cold$.multicast(() =&gt; new Subject()).refCount() 高级 SubjectpublishLast 和 AsyncSubjectpublishLast只多播上游的最后一个数据，当上游的 cold 流完结时，才会把最后一个数据传递给订阅者。 publishLast返回的多播流是可重用的，即使内部的AsyncSubject结束，新的Observer依然可以获得最后一个数据。 publishReplay 和 ReplaySubjectpublishReplay接受两个参数：bufferSize和windowTime，分别代表 Replay 的数据个数和时间长度。 publishReplay会存储部分 Replay 的数据，并把这些数据一次性传递给接下来的订阅者。 注意限制缓存大小，防止内存出错。 let cold$ = interval(1000).pipe(take(4))// replay 最新的两个数据let hot$ = cold$.pipe( publishReplay(2), refCount())// 订阅hot$.subscribe(value =&gt; console.log('observer 1: ' + value))setTimeout(() =&gt; &#123; hot$.subscribe(value =&gt; console.log('observer 2: ' + value))&#125;, 3000)setTimeout(() =&gt; &#123; hot$.subscribe(value =&gt; console.log('observer 3: ' + value))&#125;, 5000)setTimeout(() =&gt; &#123; hot$.subscribe(value =&gt; console.log('observer 4: ' + value))&#125;, 6000)// observer 1: 0// observer 1: 1// observer 1: 2// observer 2: 1// observer 2: 2// observer 1: 3// observer 2: 3// observer 3: 2// observer 3: 3// observer 4: 2// observer 4: 3 publishBehavior 和 BehaviorSubjectpublishBehavior可以指定一个默认值。这个默认值一开始是传入的参数，后会被上游的最新数据替代。 当Observer订阅时，上游流会先把“默认数据”传递给Observer，然后再传递流中的数据。 若上游 Subject 已完结，新的Observer不会接受任何数据，包括默认数据。","categories":[],"tags":[{"name":"js","slug":"js","permalink":"http://yoursite.com/tags/js/"},{"name":"rxjs","slug":"rxjs","permalink":"http://yoursite.com/tags/rxjs/"}]},{"title":"Node.js笔记之Stream","slug":"Node-js笔记之Stream","date":"2018-05-24T12:57:11.012Z","updated":"2018-05-26T13:54:31.156Z","comments":true,"path":"2018/05/24/Node-js笔记之Stream/","link":"","permalink":"http://yoursite.com/2018/05/24/Node-js笔记之Stream/","excerpt":"","text":"什么是 stream流（stream）是一种处理数据的思想——数据可以如水流一样流动，可以分段，具有方向。流的思想使它在操作大量数据或连续不断的数据具有优势。 Stream 类别Node.js 中具有四种基本类型的流： Readable - 可读流 Writable - 可写的流 Duplex - 可读写的流 Transform - 特殊的Duplex流，在读写中可以修改和变换数据 Readable 流Readable 流中的数据并不是直接流向消费者，而是先 push 到缓存池中。当数据超过缓存池的阈值标志 highWatermark 时，push 就会失败并返回 false。 Readable 流具有两种状态：flowing 和 pause —— 前者会将数据不断 pipe 给下游流，后者会停止传输数据直到下游流显示的调用 Stream.read()。 Readable 流默认是 pause 的。 flowing mode pause mode 两者状态转换情况： pause -&gt; flowing: 添加 data 事件订阅 调用.resume()转换为 flowing 调用.pipe()将数据传输给 Writable 流 flowing -&gt; pause: 未 pipe 任何流时，调用.pause()暂停 已经 pipe 到其他流上时，需要移除所有 data 订阅事件，并且逐一调用.unpipe()解除。 Writable 流数据流过来的时候，Writable 流内部通过writeOrBuffer来判断将数据是直接提供给数据消费者还是暂时先存放到缓冲区。当写入速度过快或者无消费者时，数据流会进入缓冲池缓存起来。 Duplex 流Duplex 流同时具有可写和可读流，不过两个流之间没有关系，互不干扰。 Transform 流Transform 流同样具有可写和可读的能力。不过可写流会通过一次 transform 函数的转换处理，然后作为可读流，提供给消费者。 pipe.pipe()方法是 stream 中最重要的方法。它提供了数据之间流动/桥接的方法。 具体方法如下： // 将一个可读流的数据流向一个可写流Readable.pipe(Writbale) 自定义流的实现Node.js 的stream流模块用于简单的实现流。开发者可以通过 js 的原型继承模式或更简单的构造函数方式来实现自定义流。不同种类的流必须实现相应的方法。 原型继承法// 需要实现_write方法class myWritableStream extends Writable &#123; constructor(opts) &#123; super(opts) &#125; _write(chunk, encoding, callback) &#123; console.log(chunk.toString().toUpperCase()) callback() &#125;&#125;new myWritableStream().write('test', () =&gt; &#123; console.log('write end')&#125;)// print \"TEST\" 构造函数法// transform流需要实现transform方法const myTransform = new Transform(&#123; transform(chunk, encoding, callback) &#123; this.push(chunk.toString().toUpperCase()) callback() &#125;&#125;)myTransform.write('aaa')myTransform.end()myTransform.pipe(process.stdout)// print \"AAA\" BackpressureBackpressure是指在数据流从上游生产者向下游消费者传输的过程中，上游生产速度大于下游消费速度，导致下游的 Buffer 溢出的一种现象。 由于消费者消费速度过慢或生产者生产速度过快， stream 内部可能会产生 Backpressure 现象。 Readable 流当 Readable 流处于 pause mode 或者消费速度比 push 到缓存池的速度慢时，就可能发生 Backpressure 现象。 Writable 流当外部生产者生产速度过快时，Writable 内部的队列池会装满，此时会发生 Backpressure 问题，同时 Writable 流无法再接受生产者数据流。只有当队列得到释放后，Writable 流会触发 drain 事件。 const Writable = require('stream').Writableconst writer = new Writable(&#123; write(chunk, encoding, callback) &#123; // 延迟callback setTimeout(() =&gt; &#123; callback &amp;&amp; callback() &#125;) &#125;&#125;)writeOneMillionTimes(writer, 'simple', 'utf8', () =&gt; &#123; console.log('end')&#125;)// 写入10000次function writeOneMillionTimes(writer, data, encoding, callback) &#123; // let i = 1000000 改为1万次 let i = 10000 write() function write() &#123; let ok = true while (i-- &gt; 0 &amp;&amp; ok) &#123; // 写入结束时回调 ok = writer.write(data, encoding, i === 0 ? callback : null) &#125; if (i &gt; 0) &#123; // 这里提前停下了，'drain' 事件触发后才可以继续写入 console.log('drain', i) writer.once('drain', write) &#125; &#125;&#125; 结果 drain 7268drain 4536drain 1804end Duplex 流Duplex 流是 Readable 流和 Writable 流的组合，因此内部的 Readable 流和 Writable 流的 Backpressure 问题同上。 Tansform 流由于 Transform 流输入与输出是相互关联，内部 Readable 和 Writable 的速度相同，因此内部不存在 Backpressure 问题，而会取决于外部生产者、消费者速度的影响。","categories":[],"tags":[{"name":"js","slug":"js","permalink":"http://yoursite.com/tags/js/"},{"name":"node","slug":"node","permalink":"http://yoursite.com/tags/node/"}]},{"title":"Node.js笔记之cluster","slug":"Node-js笔记之cluster","date":"2018-05-21T11:23:21.224Z","updated":"2018-05-22T13:09:12.743Z","comments":true,"path":"2018/05/21/Node-js笔记之cluster/","link":"","permalink":"http://yoursite.com/2018/05/21/Node-js笔记之cluster/","excerpt":"","text":"由于单个 Node 进程在运行时只能使用其中一个内核，因此简单的 Node 程序无法充分利用多核 CPU。为了解决这个问题，Node 提供了 cluster(集群)API。 cluster 概述cluster提供了简单的创建共享服务器端口的子进程。 const cluster = require('cluster')const http = require('http')const numCPUs = require('os').cpus().lengthif (cluster.isMaster) &#123; console.log('CPU数', numCPUs) console.log('master is running') // 根据CPU的核数进行子进程的创建 for (let i = 0; i &lt; numCPUs; i++) &#123; cluster.fork() &#125;&#125; else &#123; http .createServer(function(req, res) &#123; res.writeHead(200) res.end(`a worker running in process $&#123;process.pid&#125;`) &#125;) .listen(3000)&#125; 进程创建、销毁进程创建cluster.fork可以创建一个子进程并返回。fork行为可以通过cluster.setupMaster设置并修改。 当子进程被 fork 后，cluster主进程的fork、online事件会依次触发。 进程销毁子进程可以通过disconnect和exit销毁。当子进程退出时，子进程会断开与主进程的IPC管道，然后退出。主进程的disconnect、exit事件会依次触发。 const cluster = require('cluster')const http = require('http')const numCPUs = require('os').cpus().lengthif (cluster.isMaster) &#123; console.log('CPU数', numCPUs) console.log('master is running') for (let i = 0; i &lt; numCPUs; i++) &#123; cluster.fork() &#125; cluster.on('fork', worker =&gt; &#123; console.log(`worker $&#123;worker.id&#125; is forked`) &#125;) cluster.on('online', worker =&gt; &#123; console.log(`worker $&#123;worker.id&#125; is running`) &#125;) cluster.on('listening', (worker, address) =&gt; &#123; console.log(`A worker $&#123;worker.id&#125; is now connected to $&#123;address.address&#125;:$&#123;address.port&#125;`) &#125;) cluster.on('disconnect', worker =&gt; &#123; console.log(`worker $&#123;worker.id&#125; has disconnected`) &#125;) cluster.on('exit', function(worker, code, signal) &#123; console.log(`Worker $&#123;worker.id&#125; exit`) &#125;)&#125; else &#123; http .createServer(function(req, res) &#123; res.writeHead(200) res.end(`I am a worker running in process $&#123;process.pid&#125;`) &#125;) .listen(3000) setTimeout(() =&gt; process.disconnect(), 1000)&#125; 进程通信在cluster模块中，父子进程通过IPC的方式进行通信。 父进程消息发送：worker.send()或ChildProcess.send() 父进程消息接受：cluster监听 message 子进程消息发送：process监听 message 父子进程相互通信并且遍历cluster.workers查看运行 worker 的 id const cluster = require('cluster')const http = require('http')const numCPUs = require('os').cpus().lengthif (cluster.isMaster) &#123; console.log('[master] ' + 'start master...') for (let i = 0; i &lt; numCPUs; i++) &#123; const wk = cluster.fork() wk.send('[master] ' + 'hi worker' + wk.id) &#125; cluster.on('message', (worker, msg, handle) =&gt; &#123; console.log(`[worker] worker $&#123;worker.id&#125; : $&#123;msg&#125;`) &#125;) cluster.on('exit', (worker, code, signal) =&gt; &#123; console.log(`[worker] $&#123;worker.id&#125; disconnected`) for (let id in cluster.workers) &#123; console.log(`woker $&#123;id&#125; is working`) &#125; cluster.fork() &#125;)&#125; else &#123; process.on('message', function(msg) &#123; console.log('[worker] ' + msg) process.send('[worker] worker' + cluster.worker.id + ' received!') process.disconnect() &#125;) http.createServer().listen(3000)&#125; 负载均衡cluster模块的调度策略通过cluster.schedulingPolicy来设置。根据Node文档，除Windows外的操作系统中，cluster模块默认使用round-robin算法进行负载均衡。 在Windows系统中需要设置cluster.schedulingPolicy = cluster.SCHED_RR来启用RR算法来负载均衡 pm2PM2是一个用于Node.js应用的进程管理程序，通过`-i选项来设置来开启cluster模式。另外，PM2还具有无间断重启、增加进程个数的优势。$ pm2 start app.js -i 4","categories":[],"tags":[{"name":"js","slug":"js","permalink":"http://yoursite.com/tags/js/"},{"name":"node","slug":"node","permalink":"http://yoursite.com/tags/node/"}]},{"title":"Node.js笔记之Buffer","slug":"Node-js笔记之Buffer","date":"2018-04-22T10:40:46.000Z","updated":"2018-04-22T13:17:23.789Z","comments":true,"path":"2018/04/22/Node-js笔记之Buffer/","link":"","permalink":"http://yoursite.com/2018/04/22/Node-js笔记之Buffer/","excerpt":"","text":"Buffer概述Buffer类用于在 TCP 流或文件系统操作等场景中处理二进制数据流。其大小会在创建时确定，无法调整。 创建Buffer在V6之后的Node.js中，原有的new Buffer创建方法由于不可靠和不安全，已经被废弃。现有常用的Buffer创建办法包括： Buffer.from() Buffer.alloc() Buffer.allocUnsafe() // buf1: &lt;Buffer 00 00 00 00 00 00 00 00 00 00&gt;const buf1 = Buffer.alloc(10)// buf2: &lt;Buffer 01 01 01 01 01 01 01 01 01 01&gt;const buf2 = Buffer.alloc(10, 1)// buf3 &lt;Buffer 01 02 03 04&gt;const buf3 = Buffer.from([1, 2, 3, 4])// buf4 &lt;Buffer 74 65 73 74&gt;const buf4 = Buffer.from('test')// 由于allocUnsafe方法会导致Buffer含有旧数据，因此结果不确定// 内容必须被初始化，用buf.fill()来初始化const buf5 = Buffer.allocUnsafe(10) Buffer.allocUnsafe() 速度快，但不安全 当使用 Buffer.allocUnsafe() 分配新建的 Buffer 时，当分配的内存小于 4KB 时，默认会从一个单一的预分配的 Buffer 切割出来。 这使得应用程序可以避免垃圾回收机制因创建太多独立分配的 Buffer。 编码Node.js 目前支持的字符编码包括： ‘ascii’ - 仅支持 7 位 ASCII 数据。如果设置去掉高位的话，这种编码是非常快的。 ‘utf8’ - 多字节编码的 Unicode 字符。许多网页和其他文档格式都使用 UTF-8 。 ‘utf16le’ - 2 或 4 个字节，小字节序编码的 Unicode 字符。支持代理对（U+10000 至 U+10FFFF）。 ‘ucs2’ - ‘utf16le’ 的别名。 ‘base64’ - Base64 编码。 ‘latin1’ - 一种把 Buffer 编码成一字节编码的字符串的方式 ‘binary’ - ‘latin1’ 的别名。 ‘hex’ - 将每个字节编码为两个十六进制字符。 字符串进行编码的方式有两种： 通过Buffer.from(string[, encoding])进行 // buf6 &lt;Buffer 74 65 73 74&gt;const buf6 = Buffer.from('test', 'ascii') 通过buf.toString([encoding[, start[, end]]])进行 const buf6 = Buffer.from('test')// 74657374buf6.toString('hex') 其他类方法还有一些 Buffer 常用的 API Buffer.isBuffer：判断对象是否为 Buffer Buffer.isEncoding：判断 Buffer 对象编码 实例方法Buffer实例的API和数组有些相似，包括: buf.length：返回 内存为此 Buffer 实例所申请的字节数，并不是 Buffer 实例内容的字节数 buf.indexOf：和数组的 indexOf 类似，返回某字符串、acsii 码或者 buf 在改 buf 中的位置 buf.copy：将一个 buf 的（部分）内容复制到另外一个 buf 中 buf.equals:如果 buf 与 otherBuffer 具有完全相同的字节，则返回 true，否则返回 false buf.toJSON：将buf转换成JSON格式的数据 const buf6 = Buffer.from('test')console.log(buf6.toJSON())// 输出 &#123; type: 'Buffer', data: [ 116, 101, 115, 116 ] &#125; 一些指定字节格式读写的API 另外，Buffer实例可以用for..of进行遍历。当然，也存在buf.values() 、buf.keys() 和 buf.entries() 方法","categories":[],"tags":[{"name":"js","slug":"js","permalink":"http://yoursite.com/tags/js/"},{"name":"node","slug":"node","permalink":"http://yoursite.com/tags/node/"}]}]}